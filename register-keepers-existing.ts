/**
 * Register Keepers with Existing BLS Keys
 *
 * Uses BLS keys already generated by the keepers on VPS2.
 */

import { createWalletClient, createPublicClient, http, parseEther, formatEther, encodeFunctionData, toHex, concat } from "viem";
import { privateKeyToAccount } from "viem/accounts";

// Chain config
const RPC_URL = process.env.RPC_URL || "http://localhost:33010";
const CHAIN_ID = 111222333;

// Contract addresses (VPS2 deployment 2026-02-03)
const WIND_ADDRESS = "0x4e5b65FB12d4165E22f5861D97A33BA45c006114" as const;
const KEEPER_REGISTRY_ADDRESS = "0xE80FB0E8974EFE237fEf83B0df470664fc51fa99" as const;

// Keeper private keys (dev3, dev4, dev5)
const KEEPER_CONFIGS = [
  {
    privateKey: "0x237112963af91b42ca778fbe434a819b7e862cd025be3c86ce453bdd3e633165" as const, // dev3
    ip: "127.0.0.1:5001",
    blsPubkeyX: "0x12a815c42baafce1fee18ca857b7a0476222d49388c1c575fe2349c791d11603",
    blsPubkeyY: "0x12b58742328bd8987f9016da1fb38b206fead46300c79358a5ae9aace0e1a6e6",
  },
  {
    privateKey: "0xdbd4bf6a5edb48b1819a2e94920c156ff8296670d5df72e4b8a22df0b6ce573d" as const, // dev4
    ip: "127.0.0.1:5002",
    blsPubkeyX: "0x1057236bc19fa40318e1eee732f2b3ce30ced8d268d5fa1131ee228340ac2fb0",
    blsPubkeyY: "0x2fac987b81b4f350d02799352d58a9c5dc4086e4fd375a21c04e49de87ff0d0b",
  },
  {
    privateKey: "0xae804cd43a8471813628b123189674469b92e3874674e540b9567e9e986d394d" as const, // dev5
    ip: "127.0.0.1:5003",
    blsPubkeyX: "0x29c76f386db950fa91d83a7db8b3bfe346376737966d218e355fdcd6990ffc2f",
    blsPubkeyY: "0x1c017b6dc53e4a76c62d0c3a4a15116bf87c46da065b7e356a68afb943ec9ef6",
  },
];

// Min stake: 100 WIND
const MIN_STAKE = parseEther("100");

// ABIs
const WIND_ABI = [
  {
    name: "deposit",
    type: "function",
    inputs: [],
    outputs: [],
    stateMutability: "payable",
  },
  {
    name: "approve",
    type: "function",
    inputs: [
      { name: "spender", type: "address" },
      { name: "amount", type: "uint256" },
    ],
    outputs: [{ type: "bool" }],
    stateMutability: "nonpayable",
  },
  {
    name: "balanceOf",
    type: "function",
    inputs: [{ name: "account", type: "address" }],
    outputs: [{ type: "uint256" }],
    stateMutability: "view",
  },
] as const;

const KEEPER_REGISTRY_ABI = [
  {
    name: "registerKeeper",
    type: "function",
    inputs: [
      { name: "ip", type: "bytes32" },
      { name: "blsPubkey", type: "bytes" },
    ],
    outputs: [],
    stateMutability: "nonpayable",
  },
  {
    name: "isActiveKeeper",
    type: "function",
    inputs: [{ name: "addr", type: "address" }],
    outputs: [{ type: "bool" }],
    stateMutability: "view",
  },
  {
    name: "getActiveKeeperCount",
    type: "function",
    inputs: [],
    outputs: [{ type: "uint256" }],
    stateMutability: "view",
  },
] as const;

// Chain definition
const indexL3 = {
  id: CHAIN_ID,
  name: "Index L3",
  nativeCurrency: { name: "IND", symbol: "IND", decimals: 18 },
  rpcUrls: { default: { http: [RPC_URL] } },
} as const;

async function main() {
  console.log("=== Keeper Registration (Existing BLS Keys) ===\n");
  console.log(`RPC: ${RPC_URL}`);
  console.log(`WIND Token: ${WIND_ADDRESS}`);
  console.log(`KeeperRegistry: ${KEEPER_REGISTRY_ADDRESS}`);
  console.log(`Min Stake: ${formatEther(MIN_STAKE)} WIND\n`);

  const publicClient = createPublicClient({
    chain: indexL3,
    transport: http(RPC_URL),
  });

  // Check chain connection
  const chainId = await publicClient.getChainId();
  console.log(`Connected to chain: ${chainId}\n`);

  for (let i = 0; i < KEEPER_CONFIGS.length; i++) {
    const config = KEEPER_CONFIGS[i];
    const account = privateKeyToAccount(config.privateKey);

    console.log(`\n--- Keeper ${i + 1}: ${account.address} ---`);

    const walletClient = createWalletClient({
      account,
      chain: indexL3,
      transport: http(RPC_URL),
    });

    // Check if already registered
    const isActive = await publicClient.readContract({
      address: KEEPER_REGISTRY_ADDRESS,
      abi: KEEPER_REGISTRY_ABI,
      functionName: "isActiveKeeper",
      args: [account.address],
    });

    if (isActive) {
      console.log(`  Already registered and active!`);
      continue;
    }

    // Check native balance
    const nativeBalance = await publicClient.getBalance({ address: account.address });
    console.log(`  Native IND balance: ${formatEther(nativeBalance)}`);

    // Check WIND balance
    const windBalance = await publicClient.readContract({
      address: WIND_ADDRESS,
      abi: WIND_ABI,
      functionName: "balanceOf",
      args: [account.address],
    });
    console.log(`  WIND balance: ${formatEther(windBalance)}`);

    // If WIND balance < MIN_STAKE, wrap some IND
    if (windBalance < MIN_STAKE) {
      const wrapAmount = MIN_STAKE - windBalance + parseEther("1"); // Extra for gas
      console.log(`  Wrapping ${formatEther(wrapAmount)} IND to WIND...`);

      if (nativeBalance < wrapAmount) {
        console.log(`  ERROR: Insufficient IND balance to wrap!`);
        continue;
      }

      const wrapTx = await walletClient.sendTransaction({
        to: WIND_ADDRESS,
        value: wrapAmount,
        data: encodeFunctionData({
          abi: WIND_ABI,
          functionName: "deposit",
        }),
      });
      console.log(`  Wrap tx: ${wrapTx}`);
      await publicClient.waitForTransactionReceipt({ hash: wrapTx });
      console.log(`  Wrapped!`);
    }

    // Approve KeeperRegistry
    console.log(`  Approving KeeperRegistry...`);
    const approveTx = await walletClient.writeContract({
      address: WIND_ADDRESS,
      abi: WIND_ABI,
      functionName: "approve",
      args: [KEEPER_REGISTRY_ADDRESS, MIN_STAKE],
    });
    console.log(`  Approve tx: ${approveTx}`);
    await publicClient.waitForTransactionReceipt({ hash: approveTx });

    // Construct BLS public key as bytes (x || y)
    const blsPubkeyBytes = concat([
      config.blsPubkeyX as `0x${string}`,
      config.blsPubkeyY as `0x${string}`
    ]);
    console.log(`  BLS pubkey: ${blsPubkeyBytes.slice(0, 34)}...`);

    // Convert IP to bytes32
    const ipBytes32 = toHex(new TextEncoder().encode(config.ip).slice(0, 32), { size: 32 });
    console.log(`  IP bytes32: ${ipBytes32}`);

    // Register keeper
    console.log(`  Registering keeper...`);
    try {
      const registerTx = await walletClient.writeContract({
        address: KEEPER_REGISTRY_ADDRESS,
        abi: KEEPER_REGISTRY_ABI,
        functionName: "registerKeeper",
        args: [ipBytes32 as `0x${string}`, blsPubkeyBytes],
      });
      console.log(`  Register tx: ${registerTx}`);
      await publicClient.waitForTransactionReceipt({ hash: registerTx });
      console.log(`  âœ“ Keeper ${i + 1} registered!`);
    } catch (error) {
      console.log(`  ERROR: ${(error as Error).message}`);
    }
  }

  // Final status
  console.log("\n=== Final Status ===");
  const activeCount = await publicClient.readContract({
    address: KEEPER_REGISTRY_ADDRESS,
    abi: KEEPER_REGISTRY_ABI,
    functionName: "getActiveKeeperCount",
  });
  console.log(`Active keepers: ${activeCount}`);
}

main().catch(console.error);
